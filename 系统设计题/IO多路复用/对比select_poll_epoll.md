`select`、`poll`、`epoll` 是 Linux 系统中三种主流的 **IO 多路复用技术**，核心目标都是让单个进程/线程同时监听多个 IO 对象（如网络连接、文件描述符），但在 **效率、限制、实现方式** 上有显著差异。以下从关键维度对比三者的核心区别，并总结适用场景。


### 一、核心原理与数据结构
三者的本质都是通过 **内核协助监听 IO 事件**，但与内核的交互方式和数据结构设计完全不同：

| 技术 | 核心数据结构 | 与内核交互逻辑 |
|------|--------------|----------------|
| `select` | `fd_set`（固定大小的位图，每个 bit 对应一个文件描述符 FD） | 1. 用户需手动将待监听的 FD 放入 `fd_set`；<br>2. 每次调用 `select` 时，将整个 `fd_set` 从用户空间复制到内核空间；<br>3. 内核遍历所有 FD 检查就绪事件，将结果写回 `fd_set`，再复制回用户空间；<br>4. 用户遍历 `fd_set` 找出就绪的 FD。 |
| `poll` | `struct pollfd` 数组（每个元素包含 FD 和监听事件，动态大小） | 1. 用户将待监听的 FD 和事件放入 `pollfd` 数组；<br>2. 每次调用 `poll` 时，将整个数组复制到内核空间；<br>3. 内核遍历所有 FD 检查就绪事件，修改数组中对应的“就绪标识”，再复制回用户空间；<br>4. 用户遍历数组找出就绪的 FD。 |
| `epoll` | 内核维护的 **事件表**（红黑树存储注册的 FD，就绪链表存储就绪的 FD） | 1. 先通过 `epoll_create` 创建事件表；<br>2. 通过 `epoll_ctl` 向事件表注册/删除 FD 及监听事件（仅此时复制 FD 信息到内核）；<br>3. 调用 `epoll_wait` 时，内核直接从“就绪链表”返回就绪的 FD（无需复制整个事件表）；<br>4. 用户直接遍历就绪链表即可。 |


### 二、关键特性对比
#### 1. 文件描述符（FD）数量限制
- **`select`**：有上限，由内核宏 `FD_SETSIZE` 定义（默认 1024），无法直接突破（需重新编译内核，不现实）。  
  → 问题：高并发场景（如 10k 连接）无法支持。
- **`poll`**：无固定上限，`pollfd` 数组大小由用户动态分配（受系统内存限制）。  
  → 改进：解决了 `select` 的 FD 数量硬限制。
- **`epoll`**：无固定上限，理论上支持的 FD 数量仅受系统最大打开文件数限制（可通过 `ulimit` 调整）。  
  → 优势：轻松支持数万甚至数十万并发连接。


#### 2. 效率（时间复杂度）
- **`select` 和 `poll`**：均为 **O(n)**（n 为监听的 FD 总数）。  
  原因：每次调用时，内核必须遍历所有注册的 FD 才能判断哪些就绪；用户空间也需遍历所有 FD 找出就绪的，即使大部分 FD 是空闲的（如 10k 连接中仅 10 个活跃），仍需遍历 10k 次。  
  → 问题：FD 数量越多，效率越低，高并发场景下性能急剧下降。

- **`epoll`**：**O(1)**（与监听的 FD 总数无关，仅与就绪的 FD 数量相关）。  
  原因：内核通过“回调机制”记录就绪的 FD，放入“就绪链表”；`epoll_wait` 直接返回就绪链表，用户只需遍历就绪的 FD（如 10k 连接中 10 个活跃，仅遍历 10 次）。  
  → 优势：FD 数量越多，对比 `select`/`poll` 的优势越明显。


#### 3. 用户空间与内核空间的复制开销
- **`select`**：每次调用需将整个 `fd_set`（固定大小，如 1024 位=128 字节）从用户空间复制到内核空间，完成后再复制回用户空间。  
  → 开销：随调用次数增加累积（高并发场景下调用频繁，开销不可忽视）。

- **`poll`**：每次调用需将整个 `pollfd` 数组（大小随 FD 数量动态增长）复制到内核空间，完成后再复制回用户空间。  
  → 开销：FD 数量越多，数组越大，复制开销越大（比 `select` 更严重）。

- **`epoll`**：仅在通过 `epoll_ctl` 注册/删除 FD 时复制一次 FD 信息到内核，后续 `epoll_wait` 调用无需复制任何数据（仅传递事件表句柄）。  
  → 优势：几乎消除了用户态与内核态的复制开销，尤其适合长期运行的高并发服务。


#### 4. 触发方式
- **`select` 和 `poll`**：仅支持 **水平触发（LT，Level Triggered）**。  
  含义：只要 FD 处于“就绪状态”（如缓冲区有数据未读完），每次调用都会重复通知该 FD。  
  → 优点：编程简单，无需担心数据遗漏；  
  → 缺点：可能产生不必要的通知（如缓冲区有残留数据时），增加处理开销。

- **`epoll`**：支持 **水平触发（LT）** 和 **边缘触发（ET，Edge Triggered）**（默认 LT）。  
  - LT：与 `select`/`poll` 行为一致，适合初学者和简单场景；  
  - ET：仅在 FD 状态“从非就绪变为就绪”时通知一次（如缓冲区从空变为有数据），后续即使有残留数据也不再通知。  
    → 优点：减少无效通知，效率更高（尤其高并发场景）；  
    → 缺点：编程复杂，需一次性读完所有数据（否则会遗漏），且必须使用非阻塞 IO。


#### 5. 其他细节
- **`select`**：需手动重置 `fd_set`（每次调用后 `fd_set` 会被内核修改，下次调用前需重新初始化），容易出错。  
- **`poll`**：无需重置 `pollfd` 数组（内核仅修改“就绪标识”，不改变 FD 和事件），比 `select` 更易用。  
- **`epoll`**：事件注册后长期有效（除非主动删除），无需每次调用重新设置，适合长连接场景。


#### 6. 移植性
- **`select`**：几乎所有 UNIX-like 系统（Linux、BSD、macOS、Windows）都支持，兼容性最好。  
- **`poll`**：多数 UNIX-like 系统支持，但 Windows 仅部分支持（兼容性略差于 `select`）。  
- **`epoll`**：**Linux 特有的技术**，不支持 BSD、macOS、Windows 等系统，移植性最差。


### 三、适用场景总结
| 技术 | 核心优势 | 核心劣势 | 最佳适用场景 |
|------|----------|----------|--------------|
| `select` | 兼容性极强，实现简单 | FD 数量有限（1024），效率低（O(n)） | 1. 连接数少且固定的场景（如简单工具）；<br>2. 需跨多平台（如同时支持 Linux 和 Windows）。 |
| `poll` | 无 FD 数量限制，比 `select` 易用 | 效率低（O(n)），复制开销随 FD 增加而增大 | 连接数中等（数百到数千），且无需极致性能的场景（如内部服务）。 |
| `epoll` | 效率极高（O(1)），支持海量连接，可边缘触发 | 仅支持 Linux，ET 模式编程复杂 | 高并发场景（数万到数十万连接），如 Web 服务器（Nginx）、即时通讯后端、API 网关等。 |


### 四、一句话总结
- 小并发、跨平台 → 用 `select`；  
- 中并发、简单场景 → 用 `poll`；  
- 高并发、Linux 环境 → 必用 `epoll`（几乎所有高性能 Linux 服务都基于 `epoll` 构建，如 Nginx、Redis、Node.js 等）。