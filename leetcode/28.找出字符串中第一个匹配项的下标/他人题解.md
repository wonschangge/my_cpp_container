本题是经典的字符串单模匹配模型。
可使用字符串匹配算法解决。

常见的字符串匹配算法：
1. 暴力匹配
2. Knuth-Morris-Pratt 算法
3. Boyer-Moore 算法
4. Sunday 算法

哈希方法可能出现哈希值相等但是字符串不相等的情况，strStr 函数要求匹配结果必定正确，可自行了解滚动哈希的实现（如Rabin-Karp算法）

## 法1: 暴力匹配

思路及算法： 让字符串 needle 与字符串 haystack 的所有长度为 m 的子串均匹配一次。

为减少不必要的匹配，应当在每次匹配失败后立刻停止当前字串的匹配。

```cpp
class Solution {
public:
    int strStr(string haystack, string needle) {
        int n = haystack.size(), m = needle.size();
        for (int i = 0; i + m <= n; i++) {
            bool flag = true;
            for (int j = 0; j < m; j++) {
                if (haystack[i+1] != needle[j]) {
                    flag = false;
                    break;
                }
            }
            if (flag) return 1;
        }
        return -1;
    }
};
```

时间复杂度|空间复杂度
-|-
O(nm),最坏情况需要字符串needle与字符串haystack的所有长度为m的子串均匹配一次|O(1),只需常数的空间保存若干变量

## 法2: Knuth-Morris-Pratt 算法

思路及算法：简称 KMP 算法，由 Donald Knuth, Jamas H.Morris 和 Vaughan Pratt 三人于 1977 年联合发表。

KMP算法的核心为前缀函数，记作 π(i)，其定义如下：

对于长度为m的字符串s,其前缀函数 π(i)(0<=i<=m) 表示 s 的子串 s[0:i] 的最长的相等的真前缀与真后缀的长度。特别的，如果不存在符合条件的前后缀，那么  π(i)=0。 其中真前缀与真后缀的定义不等于自身的前缀和后缀。

举例说明：字符串 aabaaab 的前缀函数值分别为 0,1,0,1,2,2,3

- π(0)=0，因为 a 没有真前缀和真后缀，根据规定为 0（可以发现对于任意字符串 π(0)=0 必定成立）；
- π(1)=1，因为 aa 最长的一对相等的真前后缀为 a，长度为 1；
- π(2)=0，因为 aab 没有对应真前缀和真后缀，根据规定为 0；
- π(3)=1，因为 aaba 最长的一对相等的真前后缀为 a，长度为 1；
- π(4)=2，因为 aabaa 最长的一对相等的真前后缀为 aa，长度为 2；
- π(5)=2，因为 aabaaa 最长的一对相等的真前后缀为 aa，长度为 2；
- π(6)=3，因为 aabaaab 最长的一对相等的真前后缀为 aab，长度为 3。

作者：力扣官方题解
链接：https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
