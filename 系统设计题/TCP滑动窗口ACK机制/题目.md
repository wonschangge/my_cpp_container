讲一下 TCP 滑动窗口 ACK 机制

TCP 滑动窗口 ACK 机制是 TCP 协议实现**可靠传输**（确保数据不丢失、不重复、按序到达）和**流量控制**（避免发送方 overwhelm 接收方）的核心机制，本质是通过“窗口动态调整”和“确认反馈”，在“可靠性”与“传输效率”之间取得平衡。


要理解这个机制，需先明确两个核心背景：  
- TCP 是**面向连接的字节流协议**：数据以“字节”为单位传输，而非“数据包”，每个字节都有唯一的序号（Sequence Number，Seq）。  
- 早期“停等协议”的缺陷：发送方发一个数据包后必须等待接收方确认（ACK）才能发下一个，效率极低（尤其在高延迟网络中，大部分时间在等待 ACK）。  

滑动窗口 ACK 机制的核心改进是：**允许发送方在未收到全部 ACK 的情况下，连续发送多个数据包**，通过“窗口”限制并发发送的字节数，再通过 ACK 动态调整窗口大小。


### 一、核心概念：滑动窗口的本质
滑动窗口是 TCP 连接双方（发送方和接收方）各自维护的一个“字节范围”，用于管理“可发送/可接收的字节”。可以类比为“一个可移动的窗口”，窗口内的字节是“当前允许操作的范围”，窗口外的字节需等待条件满足后才能进入窗口。

#### 1. 发送方窗口（Sender Window）
发送方窗口由 3 个关键序号定义，范围是 `[已确认字节 + 1, 已确认字节 + 窗口大小]`，窗口内的字节分为 3 类：
- **已发送且已确认**：窗口左侧之外的字节（已完成传输，无需再管）。  
- **已发送但未确认**：窗口内左半部分字节（已发出，等待接收方 ACK，若超时需重传）。  
- **未发送但允许发送**：窗口内右半部分字节（未发出，但接收方已告知“有能力接收”，可直接发送，无需等待 ACK）。  

#### 2. 接收方窗口（Receiver Window）
接收方窗口由 2 个关键序号定义，范围是 `[期望接收的下一个字节, 期望接收的下一个字节 + 窗口大小]`，核心作用是**告知发送方“当前最多还能接收多少字节”**（即流量控制）：
- 窗口大小由接收方的“接收缓冲区剩余空间”决定（缓冲区快满时，窗口缩小；缓冲区空闲时，窗口扩大）。  
- 接收方通过 TCP 报文头的 **Window Size 字段**，将窗口大小反馈给发送方。


### 二、滑动窗口的“滑动”逻辑
窗口的“滑动”由**接收方的 ACK 确认**触发，核心是“确认一个字节，窗口向右移动一个单位”，具体分两步：

#### 1. 接收方：按序接收 + 反馈 ACK
接收方的核心逻辑是“按序接收字节”，并通过 ACK 告知发送方“已成功接收的最大连续字节序号”：
- 假设接收方期望接收的下一个字节序号是 `300`（即前 299 字节已确认），窗口大小为 `500`（最多能接收 300~799 字节）。  
- 若接收方成功接收 300~499 字节（连续无丢失），则会向发送方发送一个 **ACK 报文**，其中 `Acknowledgment Number（ACK 号）= 500`（表示“已接收完 499 字节，下一个期望接收 500 字节”），同时更新自身窗口为 `[500, 999]`（窗口大小仍为 500，向右滑动 200 单位）。  
- 若接收方收到 300~399 字节，但 400 字节丢失，后续收到 401~499 字节：此时接收方无法确认 400 及之后的字节（因为 TCP 要求按序确认），只会重复发送 `ACK = 400`（提醒发送方“400 字节丢失，需重传”），窗口仍保持 `[300, 799]` 不变。

#### 2. 发送方：接收 ACK + 窗口滑动
发送方收到 ACK 后，根据 ACK 号更新“已确认字节”，并向右滑动窗口：
- 假设发送方原窗口是 `[300, 799]`（已发送 300~499 字节，未发送 500~799 字节）。  
- 收到 `ACK = 500` 后，“已确认字节”更新为 499，窗口向右滑动至 `[500, 999]`：原“已发送未确认”的 300~499 字节变为“已确认”，原“未发送”的 500~799 字节变为“可发送”，同时新增 800~999 字节为“可发送”。  
- 若发送方超时未收到某部分字节的 ACK（如 400 字节），则会**重传该字节及之后所有已发送未确认的字节**（TCP 快速重传机制会优化这一点，见下文）。


### 三、关键细节：ACK 确认机制的优化
为了进一步提升效率，TCP 的 ACK 机制并非“接收一个字节就发一个 ACK”，而是有两个核心优化：

#### 1. 累积确认（Cumulative ACK）
接收方无需为每个字节单独发 ACK，而是确认“已收到的最大连续字节序号”。例如：
- 接收方收到 300、301、302 字节后，无需发 3 个 ACK，只需发一个 `ACK = 303`（表示“300~302 已全部接收，下一个要 303”）。  
- 优势：减少 ACK 报文数量，降低网络开销；即使中间某个字节丢失（如 301 丢失），接收方后续收到 302 时，仍会发 `ACK = 301`（重复确认），提醒发送方“301 丢失”。

#### 2. 延迟 ACK（Delayed ACK）
接收方收到数据后，不会立即发 ACK，而是延迟一小段时间（通常 200ms 以内），目的是“将 ACK 与接收方要发送给发送方的数据（如应用层的响应）合并”，减少一次 TCP 报文传输。例如：
- 客户端向服务器发送“请求数据”，服务器收到后，先不发 ACK，而是等应用层生成“响应数据”后，将 ACK 与响应数据打包在同一个 TCP 报文中发送给客户端。  
- 若延迟时间内没有要发送的数据，接收方会单独发送 ACK，避免发送方超时重传。


### 四、进阶机制：窗口大小的动态调整（流量控制 + 拥塞控制）
滑动窗口的“窗口大小”并非固定，而是由**接收方的流量控制**和**发送方的拥塞控制**共同决定，这是 TCP 适应网络状况的核心能力：

#### 1. 流量控制（接收方主导）：避免接收方缓冲区溢出
接收方通过 TCP 报文头的 `Window Size` 字段，告知发送方“当前接收缓冲区剩余空间”：
- 若接收方缓冲区快满（如应用层读取数据速度慢），则将 `Window Size` 设为较小值（甚至 0，即“窗口关闭”），发送方收到后会停止发送数据，直到接收方再次告知窗口大小（“窗口打开”）。  
- 例如：接收方缓冲区总大小 1000 字节，已用 800 字节，剩余 200 字节，则 `Window Size = 200`，发送方最多只能再发 200 字节。

#### 2. 拥塞控制（发送方主导）：避免网络拥塞
即使接收方窗口很大，若网络链路拥堵（如路由器缓存满导致丢包），发送方仍需减少发送速率，否则会加剧拥塞。发送方通过“拥塞窗口（Congestion Window，cwnd）”控制发送速率，最终发送方的“实际发送窗口”是 **min(接收方窗口, 拥塞窗口)**：
- 拥塞窗口的调整逻辑：  
  1. **慢启动**：连接刚建立时，cwnd 从 1 开始，每收到一个 ACK 就翻倍（1→2→4→8...），快速接近网络容量。  
  2. **拥塞避免**：当 cwnd 达到“慢启动阈值（ssthresh）”后，cwnd 改为每次 ACK 增加 1（线性增长），避免突然大量发包导致拥塞。  
  3. **拥塞恢复**：若检测到丢包（如超时或 3 次重复 ACK），则将 ssthresh 设为当前 cwnd 的一半，cwnd 重置为 1（或直接进入拥塞避免），重新缓慢增长。


### 五、典型场景：滑动窗口 ACK 机制的完整流程
以“客户端向服务器发送 1000 字节数据”为例，简化流程如下：
1. **连接建立**：TCP 三次握手时，双方协商初始窗口大小（如接收方窗口 = 500 字节，发送方拥塞窗口 = 1 字节，实际发送窗口 = min(500,1) = 1）。  
2. **发送方第一次发送**：发送 1~1 字节（受拥塞窗口限制），窗口变为 `[2, 501]`（已发送未确认：1~1；可发送：2~501）。  
3. **接收方确认**：收到 1 字节，延迟 100ms 后无数据要发，发送 `ACK = 2`（累积确认），同时告知接收方窗口仍为 500（`Window Size = 500`）。  
4. **发送方窗口滑动**：收到 `ACK = 2`，拥塞窗口翻倍为 2，实际发送窗口 = min(500,2) = 2，窗口滑动至 `[3, 502]`，发送 2~3 字节。  
5. **后续流程**：拥塞窗口继续慢启动（2→4→8...），直到达到 ssthresh 后线性增长；接收方持续通过 ACK 反馈已接收字节和剩余窗口，发送方动态调整发送速率，最终完成 1~1000 字节的传输。  
6. **异常处理**：若 100 字节丢失，接收方会重复发送 `ACK = 100`，发送方收到 3 次重复 ACK 后，快速重传 100 字节及之后的未确认字节，无需等待超时。


### 六、总结
TCP 滑动窗口 ACK 机制是一个“闭环反馈系统”，核心逻辑可概括为：
1. **接收方通过 ACK 告知“已接收的最大连续字节”**（累积确认），并通过 Window Size 告知“最多还能接收多少字节”（流量控制）。  
2. **发送方根据 ACK 滑动窗口**，允许连续发送窗口内的字节，同时通过拥塞窗口控制发送速率（避免网络拥塞）。  
3. **优化机制（延迟 ACK、快速重传）** 进一步提升效率，平衡“可靠性”与“传输速度”。

正是这套机制，让 TCP 成为了互联网中最可靠的传输层协议，支撑了 HTTP、FTP、SSH 等绝大多数应用。